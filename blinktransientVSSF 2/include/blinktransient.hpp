//
// BlinkTransient
// BlinkTransient
// BY, version 1.0.0
//
// Generated by Insight wizard (1.0.0).
//

#pragma once

#include <eye/protocol.hpp>
#include <eye/signal.hpp>

#include "blinktransient_configuration.hpp"
#include "MyBeeper.h"
#include "Pest.h"

using namespace std;

namespace user_tasks::blinktransient {

class BlinkTransient : public eye::protocol::EyerisTask<BlinkTransientConfiguration>
{
public:
    /// Default constructor.
    explicit BlinkTransient();

    /// Default destructor
    ~BlinkTransient() override = default;

    /// @see EyerisTask::eventCommand()
    void eventCommand(int command, const basic::types::JSONView& arguments) override;

    /// @see EyerisTask::eventConfiguration()
    void eventConfiguration(const BlinkTransientConfiguration::ptr_t& configuration) override;

    /// @see EyerisTask::eventConsoleChange()
    void eventConsoleChange(const basic::types::JSONView& change) override;

    /// @see EyerisTask::finalize()
    void finalize() final;

    /// @see EyerisTask::initialize()
    void initialize() final;

    /// @see EyerisTask::setup()
    void setup() final;

    /// @see EyerisTask::streamAnalog()
    void streamAnalog(const eye::signal::DataSliceAnalogBlock::ptr_t& data) override;

    /// @see EyerisTask::streamDigital()
    void streamDigital(const eye::signal::DataSliceDigitalBlock::ptr_t& data) override;

    /// @see EyerisTask::streamEye()
    void streamEye(const eye::signal::DataSliceEyeBlock::ptr_t& data) override;

    /// @see EyerisTask::streamKeyboard()
    void streamKeyboard(const eye::signal::DataSliceKeyboardBlock::ptr_t& data) override;

    /// @see EyerisTask::streamJoypad()
    void streamJoypad(const eye::signal::DataSliceJoypadBlock::ptr_t& data) override;

    /// @see EyerisTask::streamMonitor()
    void streamMonitor(const eye::signal::DataSliceMonitorBlock::ptr_t& data) override;

    /// @see EyerisTask::streamMouse()
    void streamMouse(const eye::signal::DataSliceMouseBlock::ptr_t& data) override;

    /// @see EyerisTask::streamVideoCard()
    void streamVideoCard(const eye::signal::DataSliceVideoCardBlock::ptr_t& data) override;

    /// @see EyerisTask::teardown()
    void teardown() final;

private:
    // Private definitions
    // state transition entering functions
    void SMInitStuff(unsigned int);
    void SMStartStuff(unsigned int);
    void SMConfirmFixStuff(unsigned int);
    void SMFpOnStuff(unsigned int);
    void SMGapOnStuff(unsigned int);
    void SMRampOnStuff(unsigned int);
    void SMPlateauOnStuff(unsigned int);
    void SMMaskOnStuff(unsigned int);
    void SMResponseStuff(unsigned int);
    void SMFinalStuff(unsigned int);
    void SMIntervalStuff(unsigned int);
    void SMCalibrationStuff(unsigned int);
    void SMAbortStuff(unsigned int);
    void SMBreakStuff(unsigned int);
    void SBWaitStuff(unsigned int);
    void SBDelayStuff(unsigned int);
    void SBOnStuff(unsigned int);
    void (BlinkTransient::*TransitionFuncs[17]) (unsigned int) = {
        &BlinkTransient::SMInitStuff,
        &BlinkTransient::SMStartStuff,
        &BlinkTransient::SMConfirmFixStuff,
        &BlinkTransient::SMFpOnStuff,
        &BlinkTransient::SMGapOnStuff,
        &BlinkTransient::SMRampOnStuff,
        &BlinkTransient::SMPlateauOnStuff,
        &BlinkTransient::SMMaskOnStuff,
        &BlinkTransient::SMResponseStuff,
        &BlinkTransient::SMFinalStuff,
        &BlinkTransient::SMIntervalStuff,
        &BlinkTransient::SMCalibrationStuff,
        &BlinkTransient::SMAbortStuff,
        &BlinkTransient::SMBreakStuff,
        &BlinkTransient::SBWaitStuff,
        &BlinkTransient::SBDelayStuff,
        &BlinkTransient::SBOnStuff
    };

    // other functions
    bool EyeWindowCheck(shared_ptr<eye::signal::DataSliceEye>);  // check whether eyes are in required window
    void UpdateGabor();
    void UpdateReCalibrator(shared_ptr<eye::signal::DataSliceEye>);  // for calibration of the drift
    void SaveData();

    // state definitions
    enum STATECHAIN{ SC_MAIN, SC_BEEP };

    enum STATE{
        S_MAIN_INIT,        // initial period before first trial start
        S_MAIN_START,       // display fixation and wait for eyes enter
        S_MAIN_CONFIRM_FIX, // confirm a fixation occurs
        S_MAIN_FP_ON,       // fixation point on
        S_MAIN_GAP_ON,      // gap period (nothing on the screen) on
        S_MAIN_RAMP_ON,     // gabor ramp on
        S_MAIN_PLATEAU_ON,  // gabor plateau on
        S_MAIN_MASK_ON,     // white noise mask on
        S_MAIN_RESPONSE,    // response period
        S_MAIN_FINAL,       // final state after a session
        S_MAIN_INTERVAL,    // trial-trial interval period
        S_MAIN_CALIBRATION, // calibrate the drfit of eye position caused by subject body movements or DPI system
        S_MAIN_ABORT,       // trial aborted
        S_MAIN_BREAK,       // break fixation
        S_BB_WAIT,          // wait period
        S_BB_DELAY,         // delay period, counting from FPON
        S_BB_ON             // jump the fixation point
    } CurState[2];

    void Transition(STATECHAIN, STATE, unsigned int); // transition to another state and call the enter function of that state
    
    basic::time::Timer TmrTrial;
    basic::time::Timer TmrSMain;    // timer for the main state chain
    basic::time::Timer TmrSBeep;    // timer for the blink beep state chain

    // re-calibration
    struct {
        int nTrials;     // recalibration after every n trials
        float xOffset;   // horizontal drift caused by subject body movements or DPI system; arc min
        float yOffset;   // vertical drift caused by subject body movements or DPI system; arc min
        bool isFinished; // whether the current calibration process for the drift is finished
        eye::graphics::ImagePlane::ptr_t pTarget;
        eye::graphics::ImagePlane::ptr_t pTracker;
    } reCalibrator;


    // other variables
    struct {
        unsigned char color[3];
        unsigned char breakColor[3];
        unsigned char abortColor[3];
        int xPix;
        int yPix;
        int wPix;
        int duration;   // ms
        eye::graphics::SolidPlane::ptr_t pStim;
    } FP;

    struct {
        int rampDur;    // ms
        int plateauDur; // ms
        int xPix;
        int yPix;
        int wPix;
        int hPix;
        float spFreq;    // cycles/deg
        float std;      // std of the Gaussian kernal
        float orientation; // degrees
        float phase;    // degrees
        float amplitude;    // 0 ~ bgnLuminance
        basic::time::Timer timer;
        eye::graphics::TexturedPlane::ptr_t pStim;
        eye::graphics::TexturedSurfaceShader::sptr_t pShader;
    } Gabor;

    struct {
        float fixedIntensities[2];
        Pest pests[8];
    }contrasts;

    struct {
        int xPix;
        int yPix;
        int wPix;
        int hPix;
        eye::graphics::ImagePlane::ptr_t pStim;
    } Mask;

    struct {
        float xPix; // pixels
        float yPix; // pixels
        float rPix; // radius in pixels
        bool visible;   // whether window edge is visible, or whether show pStim
        bool isCheck;   // whether check eye position and break trials
        eye::graphics::ImagePlane::ptr_t pStim;     // edge of fixation window
    } FixWindow;    // fixation window

    MyBeeper *pBeeper;

    int nTrials;
    int nCorrects;
    int nErrors;
    int curTrial;       // current trial index
    int curTrialLow;    // current low-SF trial index
    float tTrialStart;  // fixation point onset
    float tFpOn;        // subject look at the fixation dot
    float tGapOn;
    float tRampOn;
    float tPlateauOn;
    float tMaskOn;
    float tMaskOff;
    float tResponse;
    float tAbort;
    float tBreak;
    float tBlinkBeepOn;
    float Response;

    int fixConfirmDur;
    
    struct {
        unsigned int iFrame;            // the frame index when a stimulus is set to show
        STATE state;        // code of the stimulus set to show
    } VCardRefreshFrame;

    int bgnLuminance;               // background luminance (0~255)
    
    bool isResponsed;

    float hDrift;   // horizontal drift caused by subject body movements or DPI system; arc min
    float vDrift;   // vertical drift caused by subject body movements or DPI system; arc min
    bool isCalFinished; // whether the current calibration process for the drift is finished
};

}  // namespace user_tasks::blinktransient
